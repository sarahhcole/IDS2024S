1. a) [Here is the PDF of the filled in graph of programming languages.](progLangChartPuzzle.pdf)   
  b) Fortran, Lisp, Algol 58, Basic, C, sh, C++, Python, Java, Fortran 90, JavaScript, C#  
  c) lisp: 1958, basic: 1964, Algol 58: 1958, C: 1971, FORTRAN: 1954, Fortran 90: 1991, Python: 1991, C++: 1983, C#: 2000, Java:1991, JavaScript: 1995, sh: 1971
2. Electronic Numerical Integrator and Computer.
3. Computers use binary code, comprising of zeros and ones, for simplicity reasons, and because it is the easiest for computers to comprehend.
4. Registers.
5. Disk.  
6. A bit.  
7. a) Assembly.  
   b) It does not need to be interpreted to be machine-comprehensible.   
8. a) Fortran.
   b) 1950s.  
9. a) Assembly.
    b) Third generation: Fortran, C, C++
       Fourth generation: Python, R, MATLAB
10. C: 1971  
    C++: 1983  
    MATLAB: 1980s  
    Python: 1991
11. B
12. C with Classes
13. A programming ancestor of MATLAB is Fortran, and an ancestor for Python is C.
14. Registers.
15. Hard Drive.
16. Access to the register takes a fraction of a ns, whereas access to the RAM takes about 100 ns.  
17. RAM takes about 100 ns, whereas SSD takes about 100 µs.  
18. RAM takes about 100 ns, wheras HDD takes a few ms.
19. The transistor is the fundamental building block of a modern conventional computer’s CPU. It acts as a switch or amplifier.  
20. This does not work because adding more transistors required them to be so small that they do not function properly in the curcuits.  
21. The instruction fetch stage, the decode stage, and the execute stage.  
22. A CPU with a lower clock speed may outperform one with a higher clock speed if it deals with instructions more efficiently and concurrently.
23. The performance bottleneck in modern computers is most often the memory access, not the CPU speed. This is because CPU's have become increasingly faster than the typical memory access speed, so the memory access determines the efficiency frequently.  
24. The MOSFET Scaling indicates that the more transistors we can fit on an Integrated Circuit, the faster the CPU will become. Dennard scaling describes how, as transistors shrink, power usage could be reduced proportionally, keeping power density constant. Moore's law was created after this discovery, and it implies that that the transistor count in microprocessors will double every two years.  
25. 1) 64 grains.  
    2) 2080 grains.  
    3) In order to complete this task, you would need about 0.3 pounds of rice.  
26. 1) 2^63, which is about 9.22x10^18.  
    2) You would need approximately 1.84×10^19 grains of rice to fill this chess board.  
    3) You would need approximately 2.6x10^15 pounds of rice.  
    4) It would take approximately 1,317.62 years.  
27. Conditional branching (if-then-else), variables and the ability to assign values to them, and loops or recursion.  
28. Exponential growth shoots up quickly, making a steep curve on a regular graph and a straight line on a graph where only one axis is stretched out. Power-law growth increases more slowly over time, creating a gentler curve on a regular graph and a straight line when both axes are stretched out. By checking if the curve straightens out on these special graphs, one can figure out which type of growth is seen.
